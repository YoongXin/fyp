-- File generated by the BNF Converter (bnfc 2.9.5).

-- | Program to test parser.

module Main where

import Prelude
  ( ($), (.)
  , Either(..)
  , Int, (>)
  , String, (++), concat, unlines
  , Show, show
  , IO, (>>), (>>=), mapM_, putStrLn
  , FilePath
  , getContents, readFile, error
  )
import System.Environment ( getArgs )
import System.Exit        ( exitFailure )
import Control.Monad      ( when )

import AbsCoLa   
import LexCoLa   ( Token, mkPosToken )
import ParCoLa   ( pContract, myLexer )
import PrintCoLa ( Print, printTree )
import SkelCoLa  ()
import AstToFOL
import FOLToTPTP
import qualified Data.Map as Map
import Control.Monad.State
import System.IO (putStr, hFlush, stdout, getLine)

type Err        = Either String
type ParseFun a = [Token] -> Err a
type Verbosity  = Int

putStrV :: Verbosity -> String -> IO ()
putStrV v s = when (v > 1) $ putStrLn s

runFile :: (Print a, Show a) => Verbosity -> ParseFun a -> FilePath -> IO ()
runFile v p f = putStrLn f >> readFile f >>= run v p

run :: (Print a, Show a) => Verbosity -> ParseFun a -> String -> IO ()
run v p s =
  case p ts of
    Left err -> do
      putStrLn "\nParse              Failed...\n"
      putStrV v "Tokens:"
      mapM_ (putStrV v . showPosToken . mkPosToken) ts
      putStrLn err
      exitFailure
    Right tree -> do
      putStrLn "\nParse Successful!"
      showTree v tree
  where
  ts = myLexer s
  showPosToken ((l,c),t) = concat [ show l, ":", show c, "\t", show t ]

runAST :: ParseFun Contract -> String -> Either String Contract
runAST p s = case p ts of
  Right contract -> Right contract
  Left parseError -> Left $ "Parse failed: " 
  where
    ts = myLexer s

parseSentence :: String -> Contract
parseSentence sentence =
  case runAST pContract sentence of
    Left errMsg -> error ("Parsing failed: " ++ errMsg)
    Right parsedContract -> parsedContract

showTree :: (Show a, Print a) => Int -> a -> IO ()
showTree v tree = do
  putStrV v $ "\n[Abstract Syntax]\n\n" ++ show tree
  putStrV v $ "\n[Linearized tree]\n\n" ++ printTree tree

usage :: IO ()
usage = do
  putStrLn $ unlines
    [ "usage: Call with one of the following argument combinations:"
    , "  --help          Display this help message."
    , "  (no arguments)  Parse stdin verbosely."
    , "  (files)         Parse content of files verbosely."
    , "  -s (files)      Silent mode. Parse content of files silently."
    ]

main :: IO ()
main = do
  args <- getArgs
  case args of
    ["--help"] -> usage
    []         -> getContents >>= run 2 pContract
    "-s":fs    -> mapM_ (runFile 0 pContract) fs
    fs         -> mapM_ (runFile 2 pContract) fs

-- Function to interactively get user input for a contract or performance
getUserInput :: String -> IO String
getUserInput prompt = do
  putStrLn prompt
  putStr "> "
  hFlush stdout
  getLine


checkInconsistency :: IO ()
checkInconsistency = do

    contractString <- getUserInput "Enter a contract:"
    let (contract, dateDictionary, tempQuanDictionary) = runFOLConversion' (parseSentence contractString)
    let tptpContract = folToTPTPString "contract" contract

    putStrLn "\n"

    performanceString <- getUserInput "Enter a performance:"
    let performance = evalState (contractToFOLWithCheck (parseSentence performanceString)) (dateDictionary, tempQuanDictionary)
    let tptpPerformance = folToTPTPString "performance" performance

    putStrLn "%TPTP representation for the contract:"
    putStrLn tptpContract
    putStrLn "\n"

    putStrLn "%TPTP representation for the performance:"
    putStrLn tptpPerformance
    putStrLn "\n"

    putStrLn $ "fof(mustCondition, axiom, (" ++
      "! [X,Y,O,D] :" ++
      "(mustDeliver(X,Y,O,D) => delivered(X,Y,O,D)) & " ++
      "(mustPay(X,Y,O,D) => paid(X,Y,O,D)) & " ++
      "(mustCharge(X,Y,O,D) => charged(X,Y,O,D)) & " ++
      "(mustRefund(X,Y,O,D) => refunded(X,Y,O,D))" ++
      "))."

    putStrLn "\n"

    putStrLn $ "fof(forbiddenContradiction, axiom, (" ++
      "! [X, Y, D, O] : (" ++
      "(~ mayDeliver(X, Y, O, D) & delivered(X, Y, O, D)) |" ++
      "(~ mayPay(X, Y, O, D) & paid(X, Y, O, D)) |" ++
      "(~ mayCharge(X, Y, O, D) & charged(X, Y, O, D)) |" ++
      "(~ mayRefund(X, Y, O, D) & refunded(X, Y, O, D))" ++
      " => $false" ++
      ")" ++
      "))."

    

