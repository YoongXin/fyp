-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParCoLa
  ( happyError
  , myLexer
  , pContract
  , pComponent
  , pDefinition
  , pSimpleDefinition
  , pNumericalExpression
  , pOperator
  , pConditionalDefinition
  , pStatement
  , pConditionalStatement
  , pSimpleStatement
  , pCondition
  , pSimpleCondition
  , pBooleanExpression
  , pID
  , pHolds
  , pSubject
  , pVerb
  , pVerbStatus
  , pComparison
  , pEqual
  , pMore
  , pModalVerb
  , pObligation
  , pDate
  , pTemporalQuantifier
  , pTemporalOffset
  , pMonth
  , pObject
  , pNumericalObject
  , pPounds
  , pDollars
  , pEuros
  , pNonNumericalObject
  , pNum
  , pReceiver
  ) where

import Prelude

import qualified AbsCoLa
import LexCoLa

}

%name pContract Contract
%name pComponent Component
%name pDefinition Definition
%name pSimpleDefinition SimpleDefinition
%name pNumericalExpression NumericalExpression
%name pOperator Operator
%name pConditionalDefinition ConditionalDefinition
%name pStatement Statement
%name pConditionalStatement ConditionalStatement
%name pSimpleStatement SimpleStatement
%name pCondition Condition
%name pSimpleCondition SimpleCondition
%name pBooleanExpression BooleanExpression
%name pID ID
%name pHolds Holds
%name pSubject Subject
%name pVerb Verb
%name pVerbStatus VerbStatus
%name pComparison Comparison
%name pEqual Equal
%name pMore More
%name pModalVerb ModalVerb
%name pObligation Obligation
%name pDate Date
%name pTemporalQuantifier TemporalQuantifier
%name pTemporalOffset TemporalOffset
%name pMonth Month
%name pObject Object
%name pNumericalObject NumericalObject
%name pPounds Pounds
%name pDollars Dollars
%name pEuros Euros
%name pNonNumericalObject NonNumericalObject
%name pNum Num
%name pReceiver Receiver
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('            { PT _ (TS _ 1)  }
  ')'            { PT _ (TS _ 2)  }
  'AMOUNT'       { PT _ (TS _ 3)  }
  'AND'          { PT _ (TS _ 4)  }
  'ANYDATE'      { PT _ (TS _ 5)  }
  'April'        { PT _ (TS _ 6)  }
  'August'       { PT _ (TS _ 7)  }
  'C-AND'        { PT _ (TS _ 8)  }
  'DIVIDE'       { PT _ (TS _ 9)  }
  'DOLLARS'      { PT _ (TS _ 10) }
  'December'     { PT _ (TS _ 11) }
  'EQUALS'       { PT _ (TS _ 12) }
  'EUR'          { PT _ (TS _ 13) }
  'EUROS'        { PT _ (TS _ 14) }
  'February'     { PT _ (TS _ 15) }
  'GBP'          { PT _ (TS _ 16) }
  'IF'           { PT _ (TS _ 17) }
  'IS'           { PT _ (TS _ 18) }
  'January'      { PT _ (TS _ 19) }
  'July'         { PT _ (TS _ 20) }
  'June'         { PT _ (TS _ 21) }
  'MINUS'        { PT _ (TS _ 22) }
  'March'        { PT _ (TS _ 23) }
  'May'          { PT _ (TS _ 24) }
  'NAMEDOBJECT'  { PT _ (TS _ 25) }
  'November'     { PT _ (TS _ 26) }
  'OR'           { PT _ (TS _ 27) }
  'OTHEROBJECT'  { PT _ (TS _ 28) }
  'October'      { PT _ (TS _ 29) }
  'PLUS'         { PT _ (TS _ 30) }
  'POUNDS'       { PT _ (TS _ 31) }
  'REPORT'       { PT _ (TS _ 32) }
  'SOMECURRENCY' { PT _ (TS _ 33) }
  'SOMEDATE'     { PT _ (TS _ 34) }
  'September'    { PT _ (TS _ 35) }
  'THEDATE'      { PT _ (TS _ 36) }
  'THEN'         { PT _ (TS _ 37) }
  'TIMES'        { PT _ (TS _ 38) }
  'USD'          { PT _ (TS _ 39) }
  '['            { PT _ (TS _ 40) }
  ']'            { PT _ (TS _ 41) }
  'after'        { PT _ (TS _ 42) }
  'before'       { PT _ (TS _ 43) }
  'buck'         { PT _ (TS _ 44) }
  'case'         { PT _ (TS _ 45) }
  'charge'       { PT _ (TS _ 46) }
  'charged'      { PT _ (TS _ 47) }
  'day'          { PT _ (TS _ 48) }
  'days'         { PT _ (TS _ 49) }
  'deliver'      { PT _ (TS _ 50) }
  'delivered'    { PT _ (TS _ 51) }
  'equal'        { PT _ (TS _ 52) }
  'equals'       { PT _ (TS _ 53) }
  'forbidden'    { PT _ (TS _ 54) }
  'greater'      { PT _ (TS _ 55) }
  'is'           { PT _ (TS _ 56) }
  'it'           { PT _ (TS _ 57) }
  'less'         { PT _ (TS _ 58) }
  'may'          { PT _ (TS _ 59) }
  'more'         { PT _ (TS _ 60) }
  'must'         { PT _ (TS _ 61) }
  'not'          { PT _ (TS _ 62) }
  'on'           { PT _ (TS _ 63) }
  'paid'         { PT _ (TS _ 64) }
  'pay'          { PT _ (TS _ 65) }
  'quid'         { PT _ (TS _ 66) }
  'refund'       { PT _ (TS _ 67) }
  'refunded'     { PT _ (TS _ 68) }
  'shall'        { PT _ (TS _ 69) }
  'than'         { PT _ (TS _ 70) }
  'that'         { PT _ (TS _ 71) }
  'the'          { PT _ (TS _ 72) }
  'to'           { PT _ (TS _ 73) }
  'week'         { PT _ (TS _ 74) }
  'weeks'        { PT _ (TS _ 75) }
  'year'         { PT _ (TS _ 76) }
  'years'        { PT _ (TS _ 77) }
  L_Ident        { PT _ (TV $$)   }
  L_integ        { PT _ (TI $$)   }
  L_quoted       { PT _ (TL $$)   }

%%

Ident :: { AbsCoLa.Ident }
Ident  : L_Ident { AbsCoLa.Ident $1 }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

Contract :: { AbsCoLa.Contract }
Contract
  : {- empty -} { AbsCoLa.ConEmpty }
  | Component { AbsCoLa.ConComp $1 }
  | Component 'C-AND' Contract { AbsCoLa.ConAnd $1 $3 }

Component :: { AbsCoLa.Component }
Component
  : Definition { AbsCoLa.ComDef $1 }
  | ConditionalDefinition { AbsCoLa.ComConDef $1 }
  | Statement { AbsCoLa.ComState $1 }
  | ConditionalStatement { AbsCoLa.ComConState $1 }

Definition :: { AbsCoLa.Definition }
Definition
  : SimpleDefinition { AbsCoLa.DefSim $1 }
  | SimpleDefinition 'AND' Definition { AbsCoLa.DefAnd $1 $3 }

SimpleDefinition :: { AbsCoLa.SimpleDefinition }
SimpleDefinition
  : ID Subject 'IS' Subject { AbsCoLa.SimDefIs $1 $2 $4 }
  | ID Subject 'EQUALS' NumericalExpression { AbsCoLa.SimDefEq $1 $2 $4 }

NumericalExpression :: { AbsCoLa.NumericalExpression }
NumericalExpression
  : Num { AbsCoLa.NumExpNum $1 }
  | NumericalObject { AbsCoLa.NumExpObj $1 }
  | NumericalExpression Operator NumericalExpression { AbsCoLa.NumExpOp $1 $2 $3 }

Operator :: { AbsCoLa.Operator }
Operator
  : 'PLUS' { AbsCoLa.OpPlus }
  | 'MINUS' { AbsCoLa.OpMin }
  | 'TIMES' { AbsCoLa.OpMult }
  | 'DIVIDE' { AbsCoLa.OpDiv }

ConditionalDefinition :: { AbsCoLa.ConditionalDefinition }
ConditionalDefinition
  : Definition 'IF' Condition { AbsCoLa.ConDefIf $1 $3 }
  | 'IF' Condition 'THEN' Definition { AbsCoLa.ConDefIfThen $2 $4 }

Statement :: { AbsCoLa.Statement }
Statement
  : SimpleStatement { AbsCoLa.StateSim $1 }
  | SimpleStatement 'OR' Statement { AbsCoLa.StateOr $1 $3 }
  | SimpleStatement 'AND' Statement { AbsCoLa.StateAnd $1 $3 }

ConditionalStatement :: { AbsCoLa.ConditionalStatement }
ConditionalStatement
  : Statement 'IF' Condition { AbsCoLa.ConStateIf $1 $3 }
  | 'IF' Condition 'THEN' Statement { AbsCoLa.ConStateIfThen $2 $4 }

SimpleStatement :: { AbsCoLa.SimpleStatement }
SimpleStatement
  : ID Holds Subject ModalVerb Verb Object Receiver Date { AbsCoLa.SimStateOne $1 $2 $3 $4 $5 $6 $7 $8 }
  | ID Holds Subject Date ModalVerb Verb Object Receiver { AbsCoLa.SimStateTwo $1 $2 $3 $4 $5 $6 $7 $8 }
  | ID Holds Date Subject ModalVerb Verb Object Receiver { AbsCoLa.SimStateThree $1 $2 $3 $4 $5 $6 $7 $8 }
  | ID Subject ModalVerb Verb Object Receiver Date { AbsCoLa.SimStateOneNH $1 $2 $3 $4 $5 $6 $7 }
  | ID Subject Date ModalVerb Verb Object Receiver { AbsCoLa.SimStateTwoNH $1 $2 $3 $4 $5 $6 $7 }
  | ID Date Subject ModalVerb Verb Object Receiver { AbsCoLa.SimStateThreeNH $1 $2 $3 $4 $5 $6 $7 }

Condition :: { AbsCoLa.Condition }
Condition
  : SimpleCondition { AbsCoLa.CondiSim $1 }
  | SimpleCondition 'OR' Condition { AbsCoLa.CondiOr $1 $3 }
  | SimpleCondition 'AND' Condition { AbsCoLa.CondiAnd $1 $3 }

SimpleCondition :: { AbsCoLa.SimpleCondition }
SimpleCondition
  : ID Holds Subject VerbStatus Object Receiver Date { AbsCoLa.SimConOne $1 $2 $3 $4 $5 $6 $7 }
  | ID Holds Subject Date VerbStatus Object Receiver { AbsCoLa.SimConTwo $1 $2 $3 $4 $5 $6 $7 }
  | ID Holds Date Subject VerbStatus Object Receiver { AbsCoLa.SimConThree $1 $2 $3 $4 $5 $6 $7 }
  | ID Holds Subject ModalVerb Verb Object Receiver Date { AbsCoLa.SimConFour $1 $2 $3 $4 $5 $6 $7 $8 }
  | ID Holds BooleanExpression { AbsCoLa.SimConFive $1 $2 $3 }
  | ID Subject VerbStatus Object Receiver Date { AbsCoLa.SimConOneNH $1 $2 $3 $4 $5 $6 }
  | ID Subject Date VerbStatus Object Receiver { AbsCoLa.SimConTwoNH $1 $2 $3 $4 $5 $6 }
  | ID Date Subject VerbStatus Object Receiver { AbsCoLa.SimConThreeNH $1 $2 $3 $4 $5 $6 }
  | ID Subject ModalVerb Verb Object Receiver Date { AbsCoLa.SimConFourNH $1 $2 $3 $4 $5 $6 $7 }
  | ID BooleanExpression { AbsCoLa.SimConFiveNH $1 $2 }

BooleanExpression :: { AbsCoLa.BooleanExpression }
BooleanExpression
  : Subject VerbStatus Comparison Subject { AbsCoLa.BoolEx $1 $2 $3 $4 }

ID :: { AbsCoLa.ID }
ID
  : '[' Num ']' { AbsCoLa.IDSim $2 }
  | '[' Num '(' Num ')' ']' { AbsCoLa.IDRep $2 $4 }

Holds :: { AbsCoLa.Holds }
Holds
  : 'it' 'is' 'the' 'case' 'that' { AbsCoLa.HoldYes }
  | 'it' 'is' 'not' 'the' 'case' 'that' { AbsCoLa.HoldNo }

Subject :: { AbsCoLa.Subject }
Subject
  : String { AbsCoLa.SubQuoted $1 }
  | Ident { AbsCoLa.SubUnQuoted $1 }

Verb :: { AbsCoLa.Verb }
Verb
  : 'deliver' { AbsCoLa.VDel }
  | 'pay' { AbsCoLa.VPay }
  | 'charge' { AbsCoLa.VCharge }
  | 'refund' { AbsCoLa.VRefund }

VerbStatus :: { AbsCoLa.VerbStatus }
VerbStatus
  : 'delivered' { AbsCoLa.VSDel }
  | 'paid' { AbsCoLa.VSPay }
  | 'charged' { AbsCoLa.VSCharge }
  | 'refunded' { AbsCoLa.VSRefund }

Comparison :: { AbsCoLa.Comparison }
Comparison
  : 'less' 'than' { AbsCoLa.CompareLess }
  | Equal { AbsCoLa.CompareEq $1 }
  | More { AbsCoLa.CompareMore $1 }

Equal :: { AbsCoLa.Equal }
Equal : 'equals' { AbsCoLa.EqOne } | 'equal' 'to' { AbsCoLa.EqTwo }

More :: { AbsCoLa.More }
More
  : 'more' 'than' { AbsCoLa.MoreOne }
  | 'greater' 'than' { AbsCoLa.MoreTwo }

ModalVerb :: { AbsCoLa.ModalVerb }
ModalVerb
  : Obligation { AbsCoLa.ModalObli $1 }
  | 'may' { AbsCoLa.ModalPermi }
  | 'is' 'forbidden' 'to' { AbsCoLa.ModalForbi }

Obligation :: { AbsCoLa.Obligation }
Obligation
  : 'shall' { AbsCoLa.ObliOne } | 'must' { AbsCoLa.ObliTwo }

Date :: { AbsCoLa.Date }
Date
  : 'on' 'the' Num Month Num { AbsCoLa.DateSpe $3 $4 $5 }
  | 'on' 'ANYDATE' { AbsCoLa.DateAny }
  | 'on' 'SOMEDATE' Subject { AbsCoLa.DateSome $3 }
  | 'on' 'THEDATE' Subject { AbsCoLa.DateThe $3 }
  | TemporalQuantifier Num Month Num { AbsCoLa.DateQuanSpecific $1 $2 $3 $4 }
  | TemporalQuantifier 'SOMEDATE' Subject { AbsCoLa.DateQuanSome $1 $3 }
  | TemporalQuantifier 'THEDATE' Subject { AbsCoLa.DateQuanThe $1 $3 }
  | TemporalQuantifier TemporalOffset TemporalQuantifier 'SOMEDATE' Subject { AbsCoLa.DateQuanTempSome $1 $2 $3 $5 }
  | TemporalQuantifier TemporalOffset TemporalQuantifier 'THEDATE' Subject { AbsCoLa.DateQuanTempThe $1 $2 $3 $5 }

TemporalQuantifier :: { AbsCoLa.TemporalQuantifier }
TemporalQuantifier
  : 'after' { AbsCoLa.TempAfter } | 'before' { AbsCoLa.TempBefore }

TemporalOffset :: { AbsCoLa.TemporalOffset }
TemporalOffset
  : Num 'day' { AbsCoLa.TempOffDay $1 }
  | Num 'year' { AbsCoLa.TempOffYear $1 }
  | Num 'week' { AbsCoLa.TempOffWeek $1 }
  | Num 'days' { AbsCoLa.TempOffDays $1 }
  | Num 'years' { AbsCoLa.TempOffYears $1 }
  | Num 'weeks' { AbsCoLa.TempOffWeeks $1 }

Month :: { AbsCoLa.Month }
Month
  : 'January' { AbsCoLa.MJan }
  | 'February' { AbsCoLa.MFeb }
  | 'March' { AbsCoLa.MMar }
  | 'April' { AbsCoLa.MApr }
  | 'May' { AbsCoLa.MMay }
  | 'June' { AbsCoLa.MJun }
  | 'July' { AbsCoLa.MJul }
  | 'August' { AbsCoLa.MAug }
  | 'September' { AbsCoLa.MSep }
  | 'October' { AbsCoLa.MOct }
  | 'November' { AbsCoLa.MNov }
  | 'December' { AbsCoLa.MDec }

Object :: { AbsCoLa.Object }
Object
  : NumericalObject { AbsCoLa.ObjNu $1 }
  | NonNumericalObject { AbsCoLa.ObjNonNu $1 }

NumericalObject :: { AbsCoLa.NumericalObject }
NumericalObject
  : Pounds Num { AbsCoLa.NumPound $1 $2 }
  | Dollars Num { AbsCoLa.NumDol $1 $2 }
  | Euros Num { AbsCoLa.NumEur $1 $2 }
  | 'AMOUNT' Subject { AbsCoLa.NumAmount $2 }

Pounds :: { AbsCoLa.Pounds }
Pounds
  : 'GBP' { AbsCoLa.PoundOne }
  | 'POUNDS' { AbsCoLa.PoundTwo }
  | 'quid' { AbsCoLa.PoundThree }

Dollars :: { AbsCoLa.Dollars }
Dollars
  : 'USD' { AbsCoLa.DollarOne }
  | 'DOLLARS' { AbsCoLa.DollarTwo }
  | 'buck' { AbsCoLa.DollarThree }

Euros :: { AbsCoLa.Euros }
Euros : 'EUR' { AbsCoLa.EuroOne } | 'EUROS' { AbsCoLa.EuroTwo }

NonNumericalObject :: { AbsCoLa.NonNumericalObject }
NonNumericalObject
  : 'SOMECURRENCY' Subject { AbsCoLa.NonNumCurr $2 }
  | 'REPORT' Subject { AbsCoLa.NonNumRep $2 }
  | 'NAMEDOBJECT' Subject { AbsCoLa.NonNumNamed $2 }
  | 'OTHEROBJECT' Subject { AbsCoLa.NonNumOther $2 }

Num :: { AbsCoLa.Num }
Num : Integer { AbsCoLa.NumInt $1 }

Receiver :: { AbsCoLa.Receiver }
Receiver : 'to' Subject { AbsCoLa.Rec $2 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

