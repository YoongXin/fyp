-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParCola
  ( happyError
  , myLexer
  , pContract
  , pComponent
  , pDefinition
  , pSimpleDefinition
  , pNumericalExpression
  , pOperator
  , pConditionalDefinition
  , pStatement
  , pConditionalStatement
  , pSimpleStatement
  , pCondition
  , pSimpleCondition
  , pBooleanExpression
  , pID
  , pHolds
  , pSubject
  , pVerb
  , pVerbStatus
  , pComparison
  , pEqual
  , pMore
  , pModalVerb
  , pObligation
  , pDate
  , pTemporalQuantifier
  , pTemporalRange
  , pMonth
  , pObject
  , pNumericalObject
  , pPounds
  , pDollars
  , pEuros
  , pNonNumericalObject
  , pNum
  , pAdjective
  , pReceiver
  ) where

import Prelude

import qualified AbsCola
import LexCola

}

%name pContract Contract
%name pComponent Component
%name pDefinition Definition
%name pSimpleDefinition SimpleDefinition
%name pNumericalExpression NumericalExpression
%name pOperator Operator
%name pConditionalDefinition ConditionalDefinition
%name pStatement Statement
%name pConditionalStatement ConditionalStatement
%name pSimpleStatement SimpleStatement
%name pCondition Condition
%name pSimpleCondition SimpleCondition
%name pBooleanExpression BooleanExpression
%name pID ID
%name pHolds Holds
%name pSubject Subject
%name pVerb Verb
%name pVerbStatus VerbStatus
%name pComparison Comparison
%name pEqual Equal
%name pMore More
%name pModalVerb ModalVerb
%name pObligation Obligation
%name pDate Date
%name pTemporalQuantifier TemporalQuantifier
%name pTemporalRange TemporalRange
%name pMonth Month
%name pObject Object
%name pNumericalObject NumericalObject
%name pPounds Pounds
%name pDollars Dollars
%name pEuros Euros
%name pNonNumericalObject NonNumericalObject
%name pNum Num
%name pAdjective Adjective
%name pReceiver Receiver
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('            { PT _ (TS _ 1)  }
  ')'            { PT _ (TS _ 2)  }
  'ADATE'        { PT _ (TS _ 3)  }
  'ADJECTIVE'    { PT _ (TS _ 4)  }
  'AMOUNT'       { PT _ (TS _ 5)  }
  'AND'          { PT _ (TS _ 6)  }
  'ANYDATE'      { PT _ (TS _ 7)  }
  'April'        { PT _ (TS _ 8)  }
  'August'       { PT _ (TS _ 9)  }
  'C-AND'        { PT _ (TS _ 10) }
  'DIVIDE'       { PT _ (TS _ 11) }
  'DOLLARS'      { PT _ (TS _ 12) }
  'December'     { PT _ (TS _ 13) }
  'EQUALS'       { PT _ (TS _ 14) }
  'EUR'          { PT _ (TS _ 15) }
  'EUROS'        { PT _ (TS _ 16) }
  'February'     { PT _ (TS _ 17) }
  'GBP'          { PT _ (TS _ 18) }
  'IF'           { PT _ (TS _ 19) }
  'IS'           { PT _ (TS _ 20) }
  'January'      { PT _ (TS _ 21) }
  'July'         { PT _ (TS _ 22) }
  'June'         { PT _ (TS _ 23) }
  'MINUS'        { PT _ (TS _ 24) }
  'March'        { PT _ (TS _ 25) }
  'May'          { PT _ (TS _ 26) }
  'NAMEDOBJECT'  { PT _ (TS _ 27) }
  'November'     { PT _ (TS _ 28) }
  'OR'           { PT _ (TS _ 29) }
  'OTHEROBJECT'  { PT _ (TS _ 30) }
  'October'      { PT _ (TS _ 31) }
  'PLUS'         { PT _ (TS _ 32) }
  'POUNDS'       { PT _ (TS _ 33) }
  'REPORT'       { PT _ (TS _ 34) }
  'SOMECURRENCY' { PT _ (TS _ 35) }
  'September'    { PT _ (TS _ 36) }
  'THEDATE'      { PT _ (TS _ 37) }
  'THEN'         { PT _ (TS _ 38) }
  'TIMES'        { PT _ (TS _ 39) }
  'USD'          { PT _ (TS _ 40) }
  '['            { PT _ (TS _ 41) }
  ']'            { PT _ (TS _ 42) }
  'after'        { PT _ (TS _ 43) }
  'and'          { PT _ (TS _ 44) }
  'before'       { PT _ (TS _ 45) }
  'between'      { PT _ (TS _ 46) }
  'buck'         { PT _ (TS _ 47) }
  'case'         { PT _ (TS _ 48) }
  'charge'       { PT _ (TS _ 49) }
  'charged'      { PT _ (TS _ 50) }
  'deliver'      { PT _ (TS _ 51) }
  'delivered'    { PT _ (TS _ 52) }
  'equal'        { PT _ (TS _ 53) }
  'equals'       { PT _ (TS _ 54) }
  'forbidden'    { PT _ (TS _ 55) }
  'greater'      { PT _ (TS _ 56) }
  'in'           { PT _ (TS _ 57) }
  'is'           { PT _ (TS _ 58) }
  'it'           { PT _ (TS _ 59) }
  'less'         { PT _ (TS _ 60) }
  'may'          { PT _ (TS _ 61) }
  'more'         { PT _ (TS _ 62) }
  'must'         { PT _ (TS _ 63) }
  'not'          { PT _ (TS _ 64) }
  'on'           { PT _ (TS _ 65) }
  'paid'         { PT _ (TS _ 66) }
  'pay'          { PT _ (TS _ 67) }
  'quid'         { PT _ (TS _ 68) }
  'refund'       { PT _ (TS _ 69) }
  'refunded'     { PT _ (TS _ 70) }
  'shall'        { PT _ (TS _ 71) }
  'than'         { PT _ (TS _ 72) }
  'that'         { PT _ (TS _ 73) }
  'the'          { PT _ (TS _ 74) }
  'to'           { PT _ (TS _ 75) }
  'within'       { PT _ (TS _ 76) }
  L_Ident        { PT _ (TV $$)   }
  L_integ        { PT _ (TI $$)   }
  L_quoted       { PT _ (TL $$)   }

%%

Ident :: { AbsCola.Ident }
Ident  : L_Ident { AbsCola.Ident $1 }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

Contract :: { AbsCola.Contract }
Contract
  : {- empty -} { AbsCola.ConEmpty }
  | Component { AbsCola.ConComp $1 }
  | Component 'C-AND' Contract { AbsCola.ConAnd $1 $3 }

Component :: { AbsCola.Component }
Component
  : Definition { AbsCola.ComDef $1 }
  | ConditionalDefinition { AbsCola.ComConDef $1 }
  | Statement { AbsCola.ComState $1 }
  | ConditionalStatement { AbsCola.ComConState $1 }

Definition :: { AbsCola.Definition }
Definition
  : SimpleDefinition { AbsCola.DefSim $1 }
  | SimpleDefinition 'AND' Definition { AbsCola.DefAnd $1 $3 }

SimpleDefinition :: { AbsCola.SimpleDefinition }
SimpleDefinition
  : ID Subject 'IS' Subject { AbsCola.SimDefIs $1 $2 $4 }
  | ID Subject 'EQUALS' NumericalExpression { AbsCola.SimDefEq $1 $2 $4 }

NumericalExpression :: { AbsCola.NumericalExpression }
NumericalExpression
  : Num { AbsCola.NumExpNum $1 }
  | NumericalObject { AbsCola.NumExpObj $1 }
  | NumericalExpression Operator NumericalExpression { AbsCola.NumExpOp $1 $2 $3 }

Operator :: { AbsCola.Operator }
Operator
  : 'PLUS' { AbsCola.OpPlus }
  | 'MINUS' { AbsCola.OpMin }
  | 'TIMES' { AbsCola.OpMult }
  | 'DIVIDE' { AbsCola.OpDiv }

ConditionalDefinition :: { AbsCola.ConditionalDefinition }
ConditionalDefinition
  : Definition 'IF' Condition { AbsCola.ConDefIf $1 $3 }
  | 'IF' Condition 'THEN' Definition { AbsCola.ConDefIfThen $2 $4 }

Statement :: { AbsCola.Statement }
Statement
  : SimpleStatement { AbsCola.StateSim $1 }
  | SimpleStatement 'OR' Statement { AbsCola.StateOr $1 $3 }
  | SimpleStatement 'AND' Statement { AbsCola.StateAnd $1 $3 }

ConditionalStatement :: { AbsCola.ConditionalStatement }
ConditionalStatement
  : Statement 'IF' Condition { AbsCola.ConStateIf $1 $3 }
  | 'IF' Condition 'THEN' Statement { AbsCola.ConStateIfThen $2 $4 }

SimpleStatement :: { AbsCola.SimpleStatement }
SimpleStatement
  : ID Holds Subject ModalVerb Verb Object Receiver Date { AbsCola.SimStateOne $1 $2 $3 $4 $5 $6 $7 $8 }
  | ID Holds Subject Date ModalVerb Verb Object Receiver { AbsCola.SimStateTwo $1 $2 $3 $4 $5 $6 $7 $8 }
  | ID Holds Date Subject ModalVerb Verb Object Receiver { AbsCola.SimStateThree $1 $2 $3 $4 $5 $6 $7 $8 }
  | ID Subject ModalVerb Verb Object Receiver Date { AbsCola.SimStateOneNH $1 $2 $3 $4 $5 $6 $7 }
  | ID Subject Date ModalVerb Verb Object Receiver { AbsCola.SimStateTwoNH $1 $2 $3 $4 $5 $6 $7 }
  | ID Date Subject ModalVerb Verb Object Receiver { AbsCola.SimStateThreeNH $1 $2 $3 $4 $5 $6 $7 }

Condition :: { AbsCola.Condition }
Condition
  : SimpleCondition { AbsCola.CondiSim $1 }
  | SimpleCondition 'OR' Condition { AbsCola.CondiOr $1 $3 }
  | SimpleCondition 'AND' Condition { AbsCola.CondiAnd $1 $3 }

SimpleCondition :: { AbsCola.SimpleCondition }
SimpleCondition
  : ID Holds Subject VerbStatus Object Receiver Date { AbsCola.SimConOne $1 $2 $3 $4 $5 $6 $7 }
  | ID Holds Subject Date VerbStatus Object Receiver { AbsCola.SimConTwo $1 $2 $3 $4 $5 $6 $7 }
  | ID Holds Date Subject VerbStatus Object Receiver { AbsCola.SimConThree $1 $2 $3 $4 $5 $6 $7 }
  | ID Holds Subject ModalVerb Verb Object Receiver Date { AbsCola.SimConFour $1 $2 $3 $4 $5 $6 $7 $8 }
  | ID Holds BooleanExpression { AbsCola.SimConFive $1 $2 $3 }
  | ID Subject VerbStatus Object Receiver Date { AbsCola.SimConOneNH $1 $2 $3 $4 $5 $6 }
  | ID Subject Date VerbStatus Object Receiver { AbsCola.SimConTwoNH $1 $2 $3 $4 $5 $6 }
  | ID Date Subject VerbStatus Object Receiver { AbsCola.SimConThreeNH $1 $2 $3 $4 $5 $6 }
  | ID Subject ModalVerb Verb Object Receiver Date { AbsCola.SimConFourNH $1 $2 $3 $4 $5 $6 $7 }
  | ID BooleanExpression { AbsCola.SimConFiveNH $1 $2 }

BooleanExpression :: { AbsCola.BooleanExpression }
BooleanExpression
  : Subject VerbStatus Comparison Subject { AbsCola.BoolEx $1 $2 $3 $4 }

ID :: { AbsCola.ID }
ID
  : '[' Num ']' { AbsCola.IDSim $2 }
  | '[' Num '(' Num ')' ']' { AbsCola.IDRep $2 $4 }

Holds :: { AbsCola.Holds }
Holds
  : 'it' 'is' 'the' 'case' 'that' { AbsCola.HoldYes }
  | 'it' 'is' 'not' 'the' 'case' 'that' { AbsCola.HoldNo }

Subject :: { AbsCola.Subject }
Subject
  : String { AbsCola.SubQuoted $1 }
  | Ident { AbsCola.SubUnQuoted $1 }

Verb :: { AbsCola.Verb }
Verb
  : 'deliver' { AbsCola.VDel }
  | 'pay' { AbsCola.VPay }
  | 'charge' { AbsCola.VCharge }
  | 'refund' { AbsCola.VRefund }

VerbStatus :: { AbsCola.VerbStatus }
VerbStatus
  : 'delivered' { AbsCola.VSDel }
  | 'paid' { AbsCola.VSPay }
  | 'charged' { AbsCola.VSCharge }
  | 'refunded' { AbsCola.VSRefund }

Comparison :: { AbsCola.Comparison }
Comparison
  : 'less' 'than' { AbsCola.CompareLess }
  | Equal { AbsCola.CompareEq $1 }
  | More { AbsCola.CompareMore $1 }

Equal :: { AbsCola.Equal }
Equal : 'equals' { AbsCola.EqOne } | 'equal' 'to' { AbsCola.EqTwo }

More :: { AbsCola.More }
More
  : 'more' 'than' { AbsCola.MoreOne }
  | 'greater' 'than' { AbsCola.MoreTwo }

ModalVerb :: { AbsCola.ModalVerb }
ModalVerb
  : Obligation { AbsCola.ModalObli $1 }
  | 'may' { AbsCola.ModalPermi }
  | 'is' 'forbidden' 'to' { AbsCola.ModalForbi }

Obligation :: { AbsCola.Obligation }
Obligation
  : 'shall' { AbsCola.ObliOne } | 'must' { AbsCola.ObliTwo }

Date :: { AbsCola.Date }
Date
  : 'on' 'the' Num Month Num { AbsCola.DateSpe $3 $4 $5 }
  | 'on' 'ANYDATE' { AbsCola.DateAny }
  | 'on' 'ADATE' { AbsCola.DateA }
  | 'on' 'THEDATE' { AbsCola.DateThe }
  | TemporalQuantifier Month { AbsCola.DateMonRange $1 $2 }
  | TemporalQuantifier Num { AbsCola.DateYearRange $1 $2 }
  | TemporalRange { AbsCola.DateRange $1 }

TemporalQuantifier :: { AbsCola.TemporalQuantifier }
TemporalQuantifier
  : 'within' { AbsCola.TempWithin }
  | 'after' { AbsCola.TempAfter }
  | 'before' { AbsCola.TempBefore }
  | 'in' { AbsCola.TempIn }

TemporalRange :: { AbsCola.TemporalRange }
TemporalRange
  : 'between' Month 'and' Month { AbsCola.BtwMonth $2 $4 }
  | 'between' Num 'and' Num { AbsCola.BtwYear $2 $4 }

Month :: { AbsCola.Month }
Month
  : 'January' { AbsCola.MJan }
  | 'February' { AbsCola.MFeb }
  | 'March' { AbsCola.MMar }
  | 'April' { AbsCola.MApr }
  | 'May' { AbsCola.MMay }
  | 'June' { AbsCola.MJun }
  | 'July' { AbsCola.MJul }
  | 'August' { AbsCola.MAug }
  | 'September' { AbsCola.MSep }
  | 'October' { AbsCola.MOct }
  | 'November' { AbsCola.MNov }
  | 'December' { AbsCola.MDec }

Object :: { AbsCola.Object }
Object
  : NumericalObject { AbsCola.ObjNu $1 }
  | NonNumericalObject { AbsCola.ObjNonNu $1 }
  | Adjective NonNumericalObject { AbsCola.ObjAdjNonNu $1 $2 }
  | 'between' NumericalObject 'and' NumericalObject { AbsCola.ObjRange $2 $4 }

NumericalObject :: { AbsCola.NumericalObject }
NumericalObject
  : Pounds Num { AbsCola.NumPound $1 $2 }
  | Dollars Num { AbsCola.NumDol $1 $2 }
  | Euros Num { AbsCola.NumEur $1 $2 }
  | 'AMOUNT' Subject { AbsCola.NumAmount $2 }

Pounds :: { AbsCola.Pounds }
Pounds
  : 'GBP' { AbsCola.PoundOne }
  | 'POUNDS' { AbsCola.PoundTwo }
  | 'quid' { AbsCola.PoundThree }

Dollars :: { AbsCola.Dollars }
Dollars
  : 'USD' { AbsCola.DollarOne }
  | 'DOLLARS' { AbsCola.DollarTwo }
  | 'buck' { AbsCola.DollarThree }

Euros :: { AbsCola.Euros }
Euros : 'EUR' { AbsCola.EuroOne } | 'EUROS' { AbsCola.EuroTwo }

NonNumericalObject :: { AbsCola.NonNumericalObject }
NonNumericalObject
  : 'SOMECURRENCY' Subject { AbsCola.NonNumCurr $2 }
  | 'REPORT' Subject { AbsCola.NonNumRep $2 }
  | 'NAMEDOBJECT' Subject { AbsCola.NonNumNamed $2 }
  | 'OTHEROBJECT' Subject { AbsCola.NonNumOther $2 }

Num :: { AbsCola.Num }
Num : Integer { AbsCola.NumInt $1 }

Adjective :: { AbsCola.Adjective }
Adjective : 'ADJECTIVE' Subject { AbsCola.Adj $2 }

Receiver :: { AbsCola.Receiver }
Receiver : 'to' Subject { AbsCola.Rec $2 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

